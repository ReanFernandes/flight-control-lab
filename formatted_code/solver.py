from casadi import *
import numpy as np
from model import dynamics
from cost import cost

class ocp_solver:
    def __init__(self, method, Q, R, timing, solver_bounds,
                                     use_prev_as_guess = False,
                                     use_prev_control = False,  
                                     use_terminal_cost = False , 
                                     use_only_position = False, 
                                     terminal_cost_weight = 50, 
                                     degree = None, 
                                     opts = False):
        
        # initialise cost
        self.cost = cost(Q, R, use_prev_control, use_terminal_cost, use_only_position, terminal_cost_weight)
        # model variables generated from the cost function ( no need to call model class again)
        self.xdot = self.cost.xdot
        self.x = self.cost.x
        self.u = self.cost.u
        self.nx = self.cost.nx
        self.nu = self.cost.nu
        self.u_prev  = self.cost.u_prev
        self.x_ref = self.cost.x_ref
        self.x0_hat = self.cost.x0_hat
        self.hover_speed = self.cost.hover_speed
        self.use_prev_as_guess = use_prev_as_guess
        # get the variables generated by cost class
        self.use_prev_control = use_prev_control
        self.lagrange = self.cost.lagrange
        self.mayer = self.cost.mayer
        # define the timing variables
        self.N = timing["N"]
        self.T = timing["T"]
        self.Tf = timing["Tf"]
        self.h = self.T / self.N
        self.N_sim = (self.Tf * self.N / self.T)
        self.method = method
        # define the values for the initial and final states
        self.x_init = None
        self.x_des = None
        
        # define the trajectory vector that will be generated by the trajectory function
        self.x_traj = None

        # define the bounds for the solver
        self.upper_pose_limit = solver_bounds["upper_pose_limit"]
        self.lower_pose_limit = solver_bounds["lower_pose_limit"]
        self.upper_vel_limit = solver_bounds["upper_vel_limit"]
        self.lower_vel_limit = solver_bounds["lower_vel_limit"]
        self.upper_att_limit = solver_bounds["upper_att_limit"]
        self.lower_att_limit = solver_bounds["lower_att_limit"]
        self.upper_ang_limit = solver_bounds["upper_ang_limit"]
        self.lower_ang_limit = solver_bounds["lower_ang_limit"]
        
        self.upper_bounds = [*self.upper_pose_limit, *self.upper_att_limit, *self.upper_vel_limit, *self.upper_ang_limit]
        self.lower_bounds = [*self.lower_pose_limit, *self.lower_att_limit, *self.lower_vel_limit, *self.lower_ang_limit]

        self.x_initial_guess = None
        self.u_initial_guess = None
        
        self.u_min = solver_bounds["u_min"]
        self.u_max = solver_bounds["u_max"]

        # create solver variables
        # define the solver variables
        self.w = []
        self.w0 = []
        self.g = []
        self.lbg = []
        self.ubg = []
        self.lbw = []
        self.ubw = []
        self.J = 0
        self.solver = None

        # define the solution vector
        self.w_opt = None
        self.X_opt = np.zeros((self.N_sim + 1, self.nx))
        self.U_opt = np.zeros((self.N_sim, self.nu))
        self.X_opt_current = None
        self.U_opt_current = None

        # solver specific variables
        if self.method == "DMS":
            self.M = timing[" DMS_RK4_step_size"]  # numnber of integration steps for RK4
            self.nlp_opts = {"ipopt": {"print_level": 0, "max_iter": 100, "tol": 1e-6}, "print_time": 0}
            self._DMS_solver()
        elif self.method == "DC":
            self.degree = degree
            self.nlp_opts = {"ipopt": {"print_level": 0, "max_iter": 100, "tol": 1e-6}, "print_time": 0}
            self._DC_solver()

    def _DMS_solver(self):
        # define integrator function
        DT = self.h / self.M
        f_l = Function('f', [self.x, self.u], [self.xdot, self.lagrange])
        
        X0 = MX.sym('X0', self.nx, 1)
        U = MX.sym('U', self.nu, 1)
        X_l = X0
        Q_l = 0
        for j in range(self.M):
            k1, k1_q = f_l(X, U)
            k2, k2_q = f_l(X + DT / 2 * k1, U)
            k3, k3_q = f_l(X + DT / 2 * k2, U)
            k4, k4_q = f_l(X + DT * k3, U)
            X=X+DT/6*(k1+2*k2+2*k3+k4)
            Q = Q + DT / 6 * (k1_q + 2 * k2_q + 2 * k3_q + k4_q)
        F_l = Function('F_l', [X0, U], [X_l, Q_l], ['x0', 'u'], ['xf', 'qf'])

        F_m = Function('F_m', [self.x], [ self.mayer], ['x_last'], ['q_last'])

        # define the NLP
        X0 = MX.sym('X0', self.nx, 1) # the NLP variable that will mark the beginning of the shooting interval
        self.w += [X0]
        self.lbw += [*self.lower_bounds]
        self.ubw += [*self.upper_bounds]
        if self.use_prev_as_guess == False:
            self.w0 += [*self.x_initial_guess]
        else:
            self.w0 += [self.x0_hat]
        # add equality constraints, that makes the actual state at beginning equal to the initial state 
        self.g += [X0 - self.x0_hat]
        self.lbg += [0] * self.nx
        self.ubg += [0] * self.nx

        Xk = X0
        # populate the shooting interval with nodes, constraints and cost
        for k in range(self.N):
            # nlp variable for control input during interval
            Uk = MX.sym('U_' + str(k), self.nu, 1)
            self.w += [Uk]
            self.lbw += [*self.u_min]
            self.ubw += [*self.u_max]
            if self.use_prev_as_guess == False:
                self.w0 += [*self.u_initial_guess]
            else:
                self.w0 += [self.u_prev]


            # Integrate to get the next shooting node
            Fk = F_l(Xk, Uk)
            Xk_end = Fk['xf']
            self.J += Fk['qf']

            # new NLP variable for the state at the end of the shooting node
            Xk = MX.sym('X_' + str(k + 1), self.nx, 1)
            self.w += [Xk]
            self.lbw += [*self.lower_bounds]
            self.ubw += [*self.upper_bounds]
            if self.use_prev_as_guess == False:
                self.w0 += [*self.x_initial_guess]
            else:
                self.w0 += [self.x0_hat]

            # add equality constraint for the shooting node
            self.g += [Xk_end - Xk]
            self.lbg += [0] * self.nx
            self.ubg += [0] * self.nx

        # add the equality constraint to make the final state of last shooting node equal to the desired state
        self.g += [Xk - self.x_ref]
        self.lbg += [0] * self.nx
        self.ubg += [0] * self.nx

        # add the mayer term to the cost function
        F_last = F_m(Xk)
        self.J += F_last['q_last']

        self.w_opt = np.zeros(len(self.w0))
        # create the solver
        if self.use_prev_control == True or self.use_prev_as_guess== True:
            prob = {'f': self.J, 'x': vertcat(*self.w), 'g': vertcat(*self.g), 'p': vertcat(  self.x0_hat, self.u_prev, self.x_ref)}
        else: 
            prob = {'f': self.J, 'x': vertcat(*self.w), 'g': vertcat(*self.g), 'p': vertcat(  self.x0_hat, self.x_ref)}
        
        self.solver = nlpsol('solver', 'ipopt', prob, self.nlp_opts)
    
    def _DC_solver(self):

        # create the collocation polynomials
        B, C, D = self._collocation_polynomials()

        # define the integrator function
        F_l = Function('F_l', [self.x, self.u], [self.xdot, self.lagrange], ['x0', 'u'], ['xf', 'qf'])
        F_m = Function('F_m', [self.x], [ self.mayer], ['x_last'], ['q_last'])

        # create the state variable for the beginning of the shooting interval
        X0 = MX.sym('X0', self.nx, 1)
        self.w += [X0]
        self.lbw += [*self.lower_bounds]
        self.ubw += [*self.upper_bounds]
        if self.use_prev_as_guess == False:
            self.w0 += [*self.x_initial_guess]
        else:
            self.w0 += [self.x0_hat]
        # add equality constraints, that makes the actual state at beginning equal to the initial state
        self.g += [X0 - self.x0_hat]
        self.lbg += [0] * self.nx
        self.ubg += [0] * self.nx

        Xk = X0
        # populate the shooting interval with nodes, constraints and cost
        for k in range(self.N):
            # new nlp variable for control input during interval
            Uk = MX.sym('U_' + str(k), self.nu, 1)
            self.w += [Uk]
            self.lbw += [*self.u_min]
            self.ubw += [*self.u_max]
            if self.use_prev_as_guess == False:
                self.w0 += [*self.u_initial_guess]
            else:
                self.w0 += [self.u_prev]


            # state variable at the collocation points
            Xc = []
            for j in range(self.degree):
                Xkj = MX.sym('X_' + str(k) + '_' + str(j), self.nx, 1)
                Xc += [Xkj]
                self.w += [Xkj]
                self.lbw += [*self.lower_bounds]
                self.ubw += [*self.upper_bounds]
                if self.use_prev_as_guess == False:
                    self.w0 += [*self.x_initial_guess]
                else:
                    self.w0 += [self.x0_hat]

            # state approximation using the collocation polynomials
            Xk_end = D[0] * Xk
            for j in range(1,self.degree):
                # expression for state derivative at collocation point
                xp = C[0, j] * Xk
                for r in range(self.degree):
                    xp = xp + C[r + 1, j] * Xc[r]
            
                # append collocation equations
                fj, qj = F_l(Xc[j-1], Uk)
                self.g += [self.h * fj - xp]
                self.lbg += [0] * self.nx
                self.ubg += [0] * self.nx

                # add contribution to the end state
                Xk_end = Xk_end + D[j] * Xc[j-1]

                # add contribution to quadrature function
                self.J += self.h * qj * B[j]

            # new variable for state at end of shooting node
            Xk = MX.sym('X_' + str(k + 1), self.nx, 1)
            self.w += [Xk]
            self.lbw += [*self.lower_bounds]
            self.ubw += [*self.upper_bounds]
            if self.use_prev_as_guess == False:
                self.w0 += [*self.x_initial_guess]
            else:
                self.w0 += [self.x0_hat]

            # add equality constraint for the shooting node
            self.g += [Xk_end - Xk]
            self.lbg += [0] * self.nx
            self.ubg += [0] * self.nx

        # add the equality constraint to make the final state of last shooting node equal to the desired state
        self.g += [Xk - self.x_ref]
        self.lbg += [0] * self.nx
        self.ubg += [0] * self.nx

        # add the mayer term to the cost function
        F_last = F_m(Xk)
        self.J += F_last['q_last']

        self.w_opt = np.zeros(len(self.w0))


        # create the solver
        if self.use_prev_control == True or self.use_prev_as_guess== True:
            prob = {'f': self.J, 'x': vertcat(*self.w), 'g': vertcat(*self.g), 'p': vertcat(  self.x0_hat, self.u_prev, self.x_ref)}
        else:
            prob = {'f': self.J, 'x': vertcat(*self.w), 'g': vertcat(*self.g), 'p': vertcat(  self.x0_hat, self.x_ref)}

        self.solver = nlpsol('solver', 'ipopt', prob, self.nlp_opts)

    def _collocation_polynomials(self):
        degree = self.degree
        tau_root = np.append(0, collocation_points(degree, 'legendre'))

        # Coefficients of the collocation equation
        C = np.zeros((degree + 1, degree + 1))

        # Coefficients of the continuity equation
        D = np.zeros(degree + 1)

        # Coefficients of the quadrature function
        B = np.zeros(degree + 1)

        # Construct polynomial basis
        for j in range(degree + 1):
            # Construct Lagrange polynomials to get the polynomial basis at the collocation point
            p = np.poly1d([1])
            for r in range(degree + 1):
                if r != j:
                    p *= np.poly1d([1, -tau_root[r]]) / (tau_root[j] - tau_root[r])

            # Evaluate the polynomial at the final time to get the coefficients of the continuity equation
            self.D[j] = p(1.0)

            # Evaluate the time derivative of the polynomial at all collocation points to get the coefficients of the continuity equation
            pder = np.polyder(p)
            for r in range(degree + 1):
                C[j, r] = pder(tau_root[r])

            # Evaluate the integral of the polynomial to get the coefficients of the quadrature function
            pint = np.polyint(p)
            B[j] = pint(1.0)

        return B, C, D        

    def set_inital_values(self, x_init, x_des, u_init):
        self.x_init = np.concatenate((np.array(x_init), np.array(1), np.zeros(self.nx -3 -1)) ) # change this later when taking actual drone state
        self.x_des = np.concatenate((np.array(x_des), np.array(1), np.zeros(self.nx -3 -1)) ) 

        self.x_initial_guess = [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        self.u_initial_guess = [0, 0, 0, 0]

        self.X_opt_current = self.x_init
        self.X_opt[:,0] = self.X_opt_current
        self.U_opt_current = np.array([self.hover_speed, self.hover_speed, self.hover_speed, self.hover_speed])    #start from hover speed
        self.U_opt[:,0] = self.U_opt_current


    def solve_for_next_state(self):
        # solve the problem for the current state 
        if self.use_prev_control == True or self.use_prev_as_guess== True:
            sol = self.solver(x0=self.w0, lbx=self.lbw, ubx=self.ubw, lbg=self.lbg, ubg=self.ubg, p=vertcat(self.X_opt_current, self.U_opt_current, self.x_des))
        else:
            sol = self.solver(x0=self.w0, lbx=self.lbw, ubx=self.ubw, lbg=self.lbg, ubg=self.ubg, p=vertcat(self.X_opt_current, self.x_des))

        # get the optimal solution
        self.w_opt = sol['x'].full().flatten()


    def extract_next_state(self, step):
        # extract the optimal state from the solution
        if self.method == "DMS":
            self.X_opt_current = self.w_opt[self.nx + self.nu : self.nx + self.nu + self.nx]
            self.U_opt_current = self.w_opt[self.nx : self.nx + self.nu]
        elif self.method == "DC":
            self.X_opt_current = self.w_opt[ self.nx + self.nu + self.nx * self.degree: self.nx + self.nu + self.nx * self.degree + self.nx]
            self.U_opt_current = self.w_opt[self.nx : self.nx + self.nu]       

        self.X_opt[step,:] = self.X_opt_current
        self.U_opt[step,:] = self.U_opt_current

    def solve_open_loop(self):
        if self.use_prev_control == True or self.use_prev_as_guess== True:
            sol = self.solver(x0=self.w0, lbx=self.lbw, ubx=self.ubw, lbg=self.lbg, ubg=self.ubg, p=vertcat(self.X_opt_current, self.U_opt_current, self.x_des))
        else:
            sol = self.solver(x0=self.w0, lbx=self.lbw, ubx=self.ubw, lbg=self.lbg, ubg=self.ubg, p=vertcat(self.X_opt_current, self.x_des))

        self.w_opt = sol['x'].full().flatten()
        if self.method == "DMS":
            x_open_loop = np.vstack([self.w_opt[(self.nx+self.nu)*(i): (self.nx+self.nu)*(i) + self.nx] for i in range(self.N)])
            u_open_loop = np.vstack([self.w_opt[(self.nx+self.nu)*(i)+self.nx: (self.nx+self.nu)*(i)+self.nx + self.nu] for i in range(self.N)])
        elif self.method == "DC":
            x_open_loop = np.vstack([self.w_opt[(self.nx + self.nu + self.nx * self.degree)*i: (self.nx + self.nu + self.nx * self.degree)*i + self.nx] for i in range(self.N)])
            u_open_loop = np.vstack([self.w_opt[((self.nx + self.nu + self.degree*self.nx)*(i-1)+self.nx): ((self.nx + self.nu + self.degree*self.nx)*(i-1)+self.nx) + self.nu ] for i in range(self.N)])
        self.X_opt = x_open_loop
        self.U_opt = u_open_loop
       




        




        